<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Interactive Metro Spider Map</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #map {
            width: 100vw;
            height: 100vh;
        }
        .leaflet-container {
            background: #1a202c; /* Dark background for map tiles loading */
        }
        .center-crosshair {
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 3px #000, 0 0 5px #000;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            line-height: 1;
        }
        .toggle-container {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .control-panel {
            background: rgba(26, 32, 44, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        .city-selector {
            margin-bottom: 12px;
        }
        .city-selector select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #fff;
            padding: 8px 12px;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            cursor: pointer;
            width: 100%;
        }
        .city-selector select option {
            background: #1a202c;
            color: #fff;
        }
        .toggle-button {
            display: flex;
            align-items: center;
            gap: 12px;
            background: transparent;
            border: none;
            color: #fff;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 8px;
            transition: all 0.2s ease;
        }
        .toggle-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        .toggle-labels {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .toggle-label {
            white-space: nowrap;
            transition: opacity 0.3s ease;
        }
        .toggle-label.inactive {
            opacity: 0.5;
        }
        .toggle-switch {
            position: relative;
            width: 44px;
            height: 24px;
            background: #4A5568;
            border-radius: 12px;
            transition: background-color 0.3s ease;
        }
        .toggle-switch.active {
            background: #ed8936;
        }
        .toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s ease;
        }
        .toggle-switch.active .toggle-slider {
            transform: translateX(20px);
        }
        .loading-indicator {
            display: none;
            margin-left: 8px;
            width: 16px;
            height: 16px;
            border: 2px solid #4A5568;
            border-top: 2px solid #ed8936;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Info Button Styles */
        .info-button {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 1000;
            width: 40px;
            height: 40px;
            background: rgba(26, 32, 44, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        .info-button:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.05);
        }
        
        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
        }
        .modal-content {
            background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%);
            margin: 5% auto;
            padding: 30px;
            border-radius: 16px;
            width: 90%;
            max-width: 600px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            color: #fff;
            font-family: 'Inter', sans-serif;
            line-height: 1.6;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .modal-title {
            font-size: 24px;
            font-weight: 700;
            margin: 0;
        }
        .close-button {
            background: none;
            border: none;
            color: #fff;
            font-size: 28px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.2s ease;
        }
        .close-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        .modal-text {
            font-size: 16px;
            margin-bottom: 15px;
        }
        .modal-link {
            color: #ed8936;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        .modal-link:hover {
            color: #fbb870;
            text-decoration: underline;
        }
        .github-section {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 12px;
            margin-top: 20px;
            border-left: 4px solid #ed8936;
        }
        .github-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: #ed8936;
            color: #1a202c;
            padding: 10px 16px;
            border-radius: 8px;
            text-decoration: none;
            font-weight: 600;
            margin-top: 10px;
            transition: all 0.2s ease;
        }
        .github-link:hover {
            background: #fbb870;
            transform: translateY(-1px);
        }
    </style>
</head>
<body class="bg-gray-900">

    <div id="map"></div>
    
    <!-- Info Button -->
    <button class="info-button" onclick="showInfoModal()" title="About this project">
        ℹ️
    </button>

    <!-- Toggle Container -->
    <div class="toggle-container">
        <!-- City Selector -->
        <div class="control-panel">
            <div class="city-selector">
                <select id="city-selector">
                    <option value="">Loading cities...</option>
                </select>
            </div>
            
            <!-- Distance Toggle -->
            <button class="toggle-button" onclick="toggleDistanceMode()">
                <div class="toggle-labels">
                    <span class="toggle-label" id="euclidean-label">Euclidean Distance</span>
                    <span class="toggle-label inactive" id="network-label">Walking Network</span>
                </div>
                <div class="toggle-switch" id="toggle-switch">
                    <div class="toggle-slider"></div>
                </div>
                <div class="loading-indicator" id="loading-indicator"></div>
            </button>
        </div>
    </div>
    
    <!-- Info Modal -->
    <div id="info-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="modal-title">Metro Spider Map</h2>
                <button class="close-button" onclick="hideInfoModal()">&times;</button>
            </div>
            <div class="modal-text" id="modal-description">
                An interactive web map showing the 5 closest metro stations to any location, with toggle between Euclidean and actual walking distances using OpenStreetMap routing.
            </div>
            <div class="modal-text">
                This project is inspired by <a href="https://carto.mx/webmap/spoke/" target="_blank" class="modal-link">Carlos Enrique Vázquez Juárez's original work</a> and builds upon it to create an open-source, enhanced version with additional features such as pedestrian network routing and high-performance network analysis.
            </div>
            <div class="github-section">
                <div class="modal-text">
                    <strong>Open Source Project</strong><br>
                    This is a completely open-source project available on GitHub. You can view the code, contribute improvements, report issues, or fork it for your own use.
                </div>
                <a href="https://github.com/liorsteinberg/Spider-Map" target="_blank" class="github-link">
                    🔗 View on GitHub
                </a>
            </div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <script>
        console.log('🔥 JavaScript is loading...');
        
        // --- Configuration ---
        let useOSMNetwork = false; // Toggle between Euclidean and OSM network distance
        let isLoading = false;
        
        // API Configuration - works for both local development and Heroku
        const API_BASE_URL = window.location.hostname === 'localhost' ? 'http://localhost:8080' : window.location.origin;
        console.log('🌐 API Base URL:', API_BASE_URL);
        
        // --- Global Variables ---
        let currentCity = null;
        let stations = [];
        let availableCities = [];
        
        // Global variables for spatial index and map
        let stationIndex = null;
        let map = null;
        
        // Cache instances for performance
        let euclideanCache = null;
        let distanceCache = null;
        
        // Global variable to track current calculation and allow cancellation
        let currentCalculationId = 0;
        
        // Global variables for movement handling
        let moveTimeout = null;
        
        // Helper function to validate station coordinates
        function isValidStation(station) {
            if (!station || !station.lat || !station.lng || 
                typeof station.lat !== 'number' || typeof station.lng !== 'number' ||
                station.lat === 0 || station.lng === 0 ||
                isNaN(station.lat) || isNaN(station.lng) ||
                Math.abs(station.lat) > 90 || Math.abs(station.lng) > 180) {
                console.warn(`⚠️ Invalid station in ${currentCity || 'unknown'}:`, {
                    name: station ? station.name : 'undefined',
                    lat: station ? station.lat : 'undefined',
                    lng: station ? station.lng : 'undefined',
                    latType: station ? typeof station.lat : 'undefined',
                    lngType: station ? typeof station.lng : 'undefined'
                });
                return false;
            }
            return true;
        }
        
        // Initialize the app
        async function initializeApp() {
            try {
                console.log('🚀 Initializing Spider Map app...');
                
                // Initialize caches
                euclideanCache = new DistanceCache(50); // For euclidean distances  
                distanceCache = new DistanceCache(30); // For OSM routes (smaller cache, bigger objects)
                
                console.log('✅ Caches initialized');
                
                // Load available cities
                await loadCities();
                console.log('✅ Cities loaded');
                
                // Load stations for current city
                await loadStations();
                console.log('✅ Stations loaded');
                
                // Initialize map and spatial index
                initializeMap();
                console.log('✅ Map initialized');
                
                // Ensure toggle UI reflects initial Euclidean mode
                updateToggleUI();
                console.log('✅ Toggle UI initialized');
                
                console.log('🎉 App initialization complete!');
                
            } catch (error) {
                console.error('❌ Failed to initialize app:', error);
                alert('Failed to load city data. Please refresh the page.');
            }
        }
        
        async function loadCities() {
            try {
                console.log('Loading cities from API...');
                const response = await fetch(`${API_BASE_URL}/api/cities`);
                console.log('Cities API response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Cities data received:', data);
                
                availableCities = data.cities;
                currentCity = data.current_city;
                
                // Populate city selector
                const selector = document.getElementById('city-selector');
                if (!selector) {
                    throw new Error('City selector element not found');
                }
                
                selector.innerHTML = '';
                
                availableCities.forEach(city => {
                    const option = document.createElement('option');
                    option.value = city.key;
                    option.textContent = city.name;
                    option.selected = city.is_current;
                    selector.appendChild(option);
                });
                
                // Add change event listener
                selector.addEventListener('change', switchCity);
                
                console.log(`Loaded ${availableCities.length} cities, current: ${currentCity}`);
            } catch (error) {
                console.error('Failed to load cities:', error);
                throw error;
            }
        }
        
        async function loadStations() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/stations`);
                const data = await response.json();
                
                // Filter stations immediately upon loading to ensure we never work with invalid data
                const rawStations = data.stations;
                stations = rawStations.filter(station => isValidStation(station));
                
                console.log(`Loaded ${rawStations.length} stations for ${data.city_name}`);
                console.log(`📊 Station validation: ${stations.length} valid, ${rawStations.length - stations.length} invalid filtered out`);
                
                // Update modal title
                const city = availableCities.find(c => c.key === data.city);
                if (city) {
                    document.getElementById('modal-title').textContent = `${city.name} Metro Spider Map`;
                    document.getElementById('modal-description').textContent = 
                        `An interactive web map showing the 5 closest ${city.name} metro stations to any location, with toggle between Euclidean and actual walking distances using OpenStreetMap routing.`;
                }
                
            } catch (error) {
                console.error('Failed to load stations:', error);
                stations = [];
                throw error;
            }
        }
        
        async function switchCity(event) {
            const newCityKey = event.target.value;
            if (!newCityKey || newCityKey === currentCity) return;
            
            const selector = document.getElementById('city-selector');
            let originalText = null;
            
            try {
                // Show loading state
                originalText = selector.options[selector.selectedIndex].text;
                selector.disabled = true;
                selector.options[selector.selectedIndex].text = 'Switching...';
                
                // Switch city on backend
                const response = await fetch(`${API_BASE_URL}/api/cities/${newCityKey}`, {
                    method: 'POST'
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to switch city: ${response.statusText}`);
                }
                
                const data = await response.json();
                currentCity = newCityKey;
                
                // Reset to Euclidean mode when changing cities
                useOSMNetwork = false;
                updateToggleUI();
                
                // Reload stations for new city
                await loadStations();
                
                // Reinitialize spatial index and clear current results
                initializeSpatialIndex();
                clearResults();
                
                // Clear distance caches to prevent cross-city contamination
                if (euclideanCache) {
                    euclideanCache.clear();
                    console.log('🧹 Cleared Euclidean cache during city switch');
                }
                if (distanceCache) {
                    distanceCache.clear();
                    console.log('🧹 Cleared OSM cache during city switch');
                }
                
                // Redraw background stations for the new city
                map.eachLayer(layer => {
                    if (layer.options && layer.options.isBackgroundStation) {
                        map.removeLayer(layer);
                    }
                });
                
                stations.forEach(station => {
                    // Validate station coordinates before rendering
                    if (!isValidStation(station)) {
                        return; // Skip this station - warning already logged
                    }
                    
                    L.circleMarker([station.lat, station.lng], { 
                        radius: 4, 
                        color: '#4A5568', 
                        weight: 1, 
                        fillColor: '#718096', 
                        fillOpacity: 0.5,
                        isBackgroundStation: true
                    }).bindPopup(`<b>${station.name}</b>`).addTo(map);
                });
                
                // Update map view to new city center
                const city = availableCities.find(c => c.key === newCityKey);
                if (city) {
                    map.setView(city.center, city.zoom);
                }
                
                // Update closest stations in Euclidean mode after city switch
                updateClosestStations();
                
                console.log(`Switched to ${data.city.name}`);
                
                // Success: Properly update the dropdown to show the new city name
                const newCityData = availableCities.find(c => c.key === newCityKey);
                if (newCityData) {
                    selector.options[selector.selectedIndex].text = newCityData.name;
                }
                
            } catch (error) {
                console.error('Failed to switch city:', error);
                alert('Failed to switch city. Please try again.');
                
                // Error: Reset selector to previous city and restore original text
                event.target.value = currentCity;
                if (originalText) {
                    selector.options[selector.selectedIndex].text = originalText;
                }
            } finally {
                // Always re-enable the selector
                selector.disabled = false;
            }
        }
        
        function initializeMap() {
            if (stations.length === 0) {
                console.warn('No stations available to initialize map');
                return;
            }
            
            // Initialize spatial index
            initializeSpatialIndex();
            
            // Initialize the map if not already created
            if (!map) {
                const city = availableCities.find(c => c.key === currentCity);
                const center = city ? city.center : [19.4326, -99.1332]; // Default to Mexico City
                const zoom = city ? city.zoom : 11;
                
                map = L.map('map').setView(center, zoom);
                
                // Add tile layer with dark theme
                L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                    subdomains: 'abcd',
                    maxZoom: 20
                }).addTo(map);
                
                // Initialize layer groups
                linesLayer = L.layerGroup().addTo(map);
                highlightedStationsLayer = L.layerGroup().addTo(map);
                
                // Add event listeners with proper synchronization for OSM mode
                map.on('click', handleMapClick);
                
                // Improved movement handling for different calculation modes
                let isMoving = false;
                
                function handleMapMovement() {
                    isMoving = true;
                    
                    // Clear any pending updates
                    if (moveTimeout) {
                        clearTimeout(moveTimeout);
                    }
                    
                    if (useOSMNetwork) {
                        // OSM MODE: Update center marker immediately, delay expensive calculation
                        const center = map.getCenter();
                        updateCenterMarker(center);
                        
                        // Wait for movement to stop before calculating expensive OSM routes
                        moveTimeout = setTimeout(() => {
                            isMoving = false;
                            if (map) {
                                updateClosestStationsWithCenter(map.getCenter());
                            }
                        }, 300); // 300ms delay after movement stops
                    } else {
                        // EUCLIDEAN MODE: Calculate immediately on the fly for smooth real-time effect
                        const center = map.getCenter();
                        updateClosestStationsWithCenter(center);
                        
                        // Very short timeout just to prevent excessive calculations during rapid movement
                        moveTimeout = setTimeout(() => {
                            isMoving = false;
                        }, 10); // Minimal delay, just for state management
                    }
                }
                
                // Use the same handler for all movement events
                map.on('move', handleMapMovement);
                map.on('zoom', handleMapMovement);
                map.on('moveend', () => {
                    if (moveTimeout) {
                        clearTimeout(moveTimeout);
                    }
                    isMoving = false;
                    // Final update when movement completely stops (mainly for OSM mode)
                    if (useOSMNetwork) {
                        updateClosestStations();
                    }
                });
                
                // Show info modal on initial load
                setTimeout(() => {
                    showInfoModal();
                }, 500);
                
                // Establish initial center point and calculate closest stations
                // This ensures the app has a proper reference point for distance calculations
                const initialCenter = map.getCenter();
                setTimeout(() => {
                    // Add initial center marker and calculate distances
                    updateClosestStations();
                }, 200);
            }
            
            // Clear existing station markers
            map.eachLayer(layer => {
                if (layer.options && layer.options.isBackgroundStation) {
                    map.removeLayer(layer);
                }
            });
            
            // Draw all stations as subtle background dots
            stations.forEach(station => {
                // Validate station coordinates before rendering background dots
                if (!isValidStation(station)) {
                    return; // Skip this station - warning already logged
                }
                
                L.circleMarker([station.lat, station.lng], { 
                    radius: 4, 
                    color: '#4A5568', 
                    weight: 1, 
                    fillColor: '#718096', 
                    fillOpacity: 0.5,
                    isBackgroundStation: true
                }).bindPopup(`<b>${station.name}</b>`).addTo(map);
            });
            
            // Initial call to draw the elements
            updateClosestStations();
            
            // Test performance if stations are available
            if (stations.length > 0) {
                const testCenter = { lat: stations[0].lat + 0.01, lng: stations[0].lng + 0.01 };
                setTimeout(() => measureDistanceCalculationPerformance(testCenter, stations), 1000);
            }
        }
        
        function initializeSpatialIndex() {
            if (stations.length > 0) {
                stationIndex = new StationSpatialIndex(stations);
                console.log(`Spatial index initialized with ${stations.length} stations`);
            }
        }
        
        function clearResults() {
            // Clear any existing results from the map
            if (map) {
                map.eachLayer(layer => {
                    if (layer.options && (layer.options.isRoute || layer.options.isStation)) {
                        map.removeLayer(layer);
                    }
                });
            }
            
            // Also clear the layer groups used for spider web visualization
            if (linesLayer) linesLayer.clearLayers();
            if (highlightedStationsLayer) highlightedStationsLayer.clearLayers();
            if (centerMarker) {
                map.removeLayer(centerMarker);
                centerMarker = null;
            }
        }
        
        function handleMapClick(e) {
            const center = e.latlng;
            
            console.log(`🖱️ Map clicked at: ${center.lat.toFixed(6)}, ${center.lng.toFixed(6)}`);
            
            // Cancel any pending movement calculations
            if (moveTimeout) {
                clearTimeout(moveTimeout);
                moveTimeout = null;
            }
            
            // For clicks, we want immediate response regardless of mode
            // The calculation function will handle loading states appropriately
            updateClosestStationsWithCenter(center);
        }
        
        // Spatial grid index for ultra-fast station lookups
        class StationSpatialIndex {
            constructor(stations, gridSize = 0.01) { // ~1km grid cells
                this.gridSize = gridSize;
                this.grid = new Map();
                this.stations = stations;
                this.buildIndex();
            }
            
            buildIndex() {
                this.stations.forEach(station => {
                    const gridKey = this.getGridKey(station.lat, station.lng);
                    if (!this.grid.has(gridKey)) {
                        this.grid.set(gridKey, []);
                    }
                    this.grid.get(gridKey).push(station);
                });
                console.log(`Spatial index built with ${this.grid.size} grid cells for ${this.stations.length} stations`);
            }
            
            getGridKey(lat, lng) {
                const gridLat = Math.floor(lat / this.gridSize);
                const gridLng = Math.floor(lng / this.gridSize);
                return `${gridLat},${gridLng}`;
            }
            
            getNearbyStations(centerLat, centerLng, radius = 5000) {
                // Convert radius to grid cell distance
                const gridRadius = Math.ceil(radius / (this.gridSize * 111000)); // rough conversion
                const centerGridLat = Math.floor(centerLat / this.gridSize);
                const centerGridLng = Math.floor(centerLng / this.gridSize);
                
                const nearbyStations = [];
                
                // Check surrounding grid cells
                for (let latOffset = -gridRadius; latOffset <= gridRadius; latOffset++) {
                    for (let lngOffset = -gridRadius; lngOffset <= gridRadius; lngOffset++) {
                        const gridKey = `${centerGridLat + latOffset},${centerGridLng + lngOffset}`;
                        const cellStations = this.grid.get(gridKey);
                        if (cellStations) {
                            nearbyStations.push(...cellStations);
                        }
                    }
                }
                
                return nearbyStations;
            }
        }
        
        // Distance calculation cache for repeated queries with OSM route caching
        class DistanceCache {
            constructor(maxSize = 50) { // Reduced size for faster lookups
                this.cache = new Map();
                this.maxSize = maxSize;
                this.currentCity = null; // Track which city the cache is for
            }
            
            getCacheKey(lat, lng, precision = 4) { // ~100m precision for responsive caching
                // Round to specified decimal places to create cache key
                const roundedLat = Math.round(lat * Math.pow(10, precision)) / Math.pow(10, precision);
                const roundedLng = Math.round(lng * Math.pow(10, precision)) / Math.pow(10, precision);
                // Only include city in cache key if currentCity is set to avoid issues during initialization
                const cityPrefix = this.currentCity ? `${this.currentCity}:` : '';
                return `${cityPrefix}${roundedLat},${roundedLng}`;
            }
            
            get(centerLat, centerLng) {
                // ALWAYS auto-clear cache if city changed or is different
                if (this.currentCity !== currentCity) {
                    console.log(`🧹 Auto-clearing OSM cache: city changed from ${this.currentCity} to ${currentCity}`);
                    this.clear();
                    this.currentCity = currentCity;
                    return null; // Force recalculation
                }
                
                // Update current city if not set
                if (!this.currentCity) {
                    this.currentCity = currentCity;
                }
                
                const key = this.getCacheKey(centerLat, centerLng);
                const cached = this.cache.get(key);
                if (cached) {
                    console.log(`🚀 Using cached OSM routes for ${currentCity || 'unknown'} - instant response!`);
                    
                    // Extra validation: ensure all cached stations are valid for current city
                    const validCached = cached.filter(station => isValidStation(station));
                    if (validCached.length !== cached.length) {
                        console.warn(`⚠️ Found ${cached.length - validCached.length} invalid stations in cache, clearing...`);
                        this.clear();
                        return null;
                    }
                }
                return cached;
            }
            
            set(centerLat, centerLng, result) {
                // Update current city when setting cache
                this.currentCity = currentCity;
                
                // Validate all stations before caching
                const validResult = result.filter(station => isValidStation(station));
                if (validResult.length !== result.length) {
                    console.warn(`⚠️ Filtering out ${result.length - validResult.length} invalid stations before caching`);
                }
                
                const key = this.getCacheKey(centerLat, centerLng);
                
                // Implement LRU cache by removing oldest entry
                if (this.cache.size >= this.maxSize) {
                    const firstKey = this.cache.keys().next().value;
                    this.cache.delete(firstKey);
                }
                
                this.cache.set(key, validResult);
                console.log(`💾 Cached ${validResult.length} valid OSM routes for ${currentCity || 'unknown'} at ${key} (${this.cache.size}/${this.maxSize})`);
            }
            
            clear() {
                this.cache.clear();
                this.currentCity = null;
                console.log('🧹 OSM cache cleared');
            }
        }

        // --- Legacy initialization code removed ---
        // This section will be replaced by initializeApp() function

        // --- Legacy tile layer and modal code removed ---
        
        // --- Cache classes ---
        let linesLayer = null;
        let highlightedStationsLayer = null;
        let centerMarker = null;

        // --- Throttle Function for Performance ---
        // This function limits how often another function can be called.
        // It prevents the update function from running too frequently during rapid map movements.
        function throttle(func, limit) {
            let inThrottle;
            return function() {
                const args = arguments;
                const context = this;
                if (!inThrottle) {
                    func.apply(context, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            }
        }

        // --- Core Logic ---
        async function updateClosestStations() {
            const center = map.getCenter();
            if (!center || !center.lat || !center.lng) {
                console.error('Invalid map center, skipping update');
                return;
            }
            
            // Pass the current map center to the main calculation function
            // The center marker will be updated there to ensure perfect sync
            await updateClosestStationsWithCenter(center);
        }
        
        async function updateClosestStationsWithCenter(center) {
            if (!map || !stations || stations.length === 0) {
                console.log('Skipping updateClosestStationsWithCenter: not ready', {
                    hasMap: !!map,
                    stationsCount: stations ? stations.length : 0
                });
                return;
            }
            
            if (!center || !center.lat || !center.lng) {
                console.error('Invalid center provided to updateClosestStationsWithCenter');
                return;
            }

            // Cancel any previous calculation and start a new one
            currentCalculationId++;
            const thisCalculationId = currentCalculationId;
            console.log(`🔄 Starting calculation ${thisCalculationId} for center:`, center.lat.toFixed(4), center.lng.toFixed(4));

            let closestStations;
            
            if (useOSMNetwork) {
                // OSM MODE: Special handling for async calculations
                
                // Check if already loading - if so, we're replacing an in-progress calculation
                if (isLoading) {
                    console.log(`🔄 Replacing in-progress OSM calculation with new one (${thisCalculationId})`);
                }
                
                // Set loading state immediately
                isLoading = true;
                showLoading(true);
                
                // Update center marker immediately for responsive feedback
                updateCenterMarker(center);
                
                // Show loading state by dimming existing routes (but keep them visible)
                if (linesLayer) {
                    linesLayer.eachLayer(layer => {
                        if (layer.setStyle) {
                            layer.setStyle({ opacity: 0.3, fillOpacity: 0.3 });
                        }
                    });
                }
                if (highlightedStationsLayer) {
                    highlightedStationsLayer.eachLayer(layer => {
                        if (layer.setStyle) {
                            layer.setStyle({ opacity: 0.3, fillOpacity: 0.3 });
                        }
                    });
                }
                
                try {
                    // Early cancellation check
                    if (thisCalculationId !== currentCalculationId) {
                        console.log(`⏭️ OSM calculation ${thisCalculationId} cancelled before starting`);
                        return;
                    }
                    
                    // Pre-filter to nearby stations for performance
                    const nearbyStations = getStationsInRadius(center, stations, 10000);
                    console.log(`🗺️ OSM mode: Processing ${nearbyStations.length} nearby stations`);
                    
                    closestStations = await calculateOSMDistances(center, nearbyStations, thisCalculationId);
                    
                    // Final cancellation check after async operation
                    if (thisCalculationId !== currentCalculationId) {
                        console.log(`⏭️ OSM calculation ${thisCalculationId} cancelled after completion`);
                        return;
                    }
                    
                } catch (error) {
                    // Only handle error if this calculation is still current
                    if (thisCalculationId !== currentCalculationId) {
                        console.log(`⏭️ OSM calculation ${thisCalculationId} cancelled during error`);
                        return;
                    }
                    
                    console.error('OSM calculation failed, falling back to Euclidean:', error);
                    closestStations = calculateEuclideanDistancesWithCache(center);
                    
                } finally {
                    // Only cleanup if this is still the current calculation
                    if (thisCalculationId === currentCalculationId) {
                        isLoading = false;
                        showLoading(false);
                    }
                }
                
            } else {
                // EUCLIDEAN MODE: Fast synchronous calculation
                
                // Update center marker immediately
                updateCenterMarker(center);
                
                // Clear existing routes immediately for instant feedback
                linesLayer.clearLayers();
                highlightedStationsLayer.clearLayers();
                
                // Calculate distances (fast, no async)
                closestStations = calculateEuclideanDistancesWithCache(center);
                console.log(`📏 Euclidean mode - found ${closestStations.length} stations`);
            }

            // Validate results
            if (!closestStations || closestStations.length === 0) {
                console.error('No closest stations found!');
                return;
            }

            // Final cancellation check before rendering
            if (thisCalculationId !== currentCalculationId) {
                console.log(`⏭️ Calculation ${thisCalculationId} cancelled before rendering`);
                return;
            }

            // Validate center coordinates before rendering
            if (!center || !center.lat || !center.lng || 
                typeof center.lat !== 'number' || typeof center.lng !== 'number' ||
                isNaN(center.lat) || isNaN(center.lng) ||
                Math.abs(center.lat) > 90 || Math.abs(center.lng) > 180) {
                console.error('Invalid center coordinates for rendering:', center);
                return;
            }

            // RENDER RESULTS
            console.log(`✅ Rendering results for calculation ${thisCalculationId}`);
            console.log(`📊 Drawing spider web from center: ${center.lat.toFixed(6)}, ${center.lng.toFixed(6)}`);
            console.log(`🗂️ Closest stations to render:`, closestStations.map(s => ({
                name: s.name,
                lat: s.lat,
                lng: s.lng,
                distance: Math.round(s.distance)
            })));

            // Clear old routes and prepare for new ones
            linesLayer.clearLayers();
            highlightedStationsLayer.clearLayers();

            // Draw the spider web
            closestStations.forEach((station, index) => {
                // CRITICAL: Validate station coordinates before rendering
                if (!isValidStation(station)) {
                    return; // Skip this station - warning already logged
                }
                
                const stationLatLng = L.latLng(station.lat, station.lng);
                
                // Ensure center coordinates are properly handled for precise alignment
                const preciseCenter = L.latLng(center.lat, center.lng);
                
                // Draw route or straight line based on mode and data availability
                if (useOSMNetwork && station.route && station.route.length > 0) {
                    // Validate OSM route coordinates before rendering
                    const validRoute = station.route.filter(point => {
                        if (!point || point.length !== 2 || 
                            typeof point[0] !== 'number' || typeof point[1] !== 'number' ||
                            isNaN(point[0]) || isNaN(point[1]) ||
                            point[0] === 0 || point[1] === 0 ||
                            Math.abs(point[0]) > 90 || Math.abs(point[1]) > 180) {
                            console.warn(`⚠️ Invalid OSM route point filtered:`, point);
                            return false;
                        }
                        return true;
                    });
                    
                    if (validRoute.length > 1) {
                        console.log(`🛣️ Drawing OSM route for ${station.name}: ${validRoute.length} valid points`);
                        L.polyline(validRoute, { 
                            color: '#ed8936', 
                            weight: 3, 
                            opacity: 0.8,
                            dashArray: '5, 5'  // Dashed line for OSM routes
                        }).addTo(linesLayer);
                    } else {
                        console.warn(`⚠️ OSM route for ${station.name} has no valid points, drawing straight line`);
                        // Fallback to straight line
                        console.log(`📏 Fallback line: center [${preciseCenter.lat.toFixed(6)}, ${preciseCenter.lng.toFixed(6)}] → station [${station.lat.toFixed(6)}, ${station.lng.toFixed(6)}]`);
                        L.polyline([preciseCenter, stationLatLng], { 
                            color: '#ed8936', 
                            weight: 2, 
                            opacity: 0.7 
                        }).addTo(linesLayer);
                    }
                } else {
                    // Draw straight line (Euclidean or fallback)
                    console.log(`� Drawing straight line for ${station.name}: center [${preciseCenter.lat.toFixed(6)}, ${preciseCenter.lng.toFixed(6)}] → station [${station.lat.toFixed(6)}, ${station.lng.toFixed(6)}]`);
                    L.polyline([preciseCenter, stationLatLng], { 
                        color: '#ed8936', 
                        weight: 2, 
                        opacity: 0.7 
                    }).addTo(linesLayer);
                }
                
                // Draw station marker
                L.circleMarker(stationLatLng, { 
                    radius: 8, 
                    color: '#FFFFFF', 
                    weight: 2, 
                    fillColor: '#ed8936', 
                    fillOpacity: 1 
                }).bindPopup(`<b>${station.name}</b><br>Distance: ${Math.round(station.distance)}m`).addTo(highlightedStationsLayer);
            });
            
            console.log(`🎯 Successfully rendered ${closestStations.length} stations for calculation ${thisCalculationId}`);
        }

        function updateCenterMarker(center) {
            // Remove existing center marker
            if (centerMarker) {
                map.removeLayer(centerMarker);
                centerMarker = null;
            }

            // Ensure center coordinates are properly rounded to prevent floating point precision issues
            const preciseCenter = L.latLng(center.lat, center.lng);

            // Use CSS flexbox centering for perfect alignment
            const centerIcon = L.divIcon({
                className: 'center-crosshair',
                html: '<b>+</b>',
                iconSize: [24, 24],
                iconAnchor: [12, 12] // Now properly centered with CSS flexbox
            });
            centerMarker = L.marker(preciseCenter, { icon: centerIcon, interactive: false, zIndexOffset: 1000 }).addTo(map);
            
            // Store the calculation ID this marker belongs to for debugging
            if (centerMarker) {
                centerMarker._calculationId = currentCalculationId;
            }
            
            console.log(`📍 Center marker updated to: ${preciseCenter.lat.toFixed(6)}, ${preciseCenter.lng.toFixed(6)} (calc ID: ${currentCalculationId})`);
        }
        
        // --- Distance Calculation Functions ---
        
        // Optimized Euclidean distance calculation using vectorized operations
        function calculateEuclideanDistances(center, stations) {
            const centerLat = center.lat;
            const centerLng = center.lng;
            const results = [];
            
            // Batch process stations for better performance
            for (let i = 0; i < stations.length; i++) {
                const station = stations[i];
                
                // CRITICAL: Validate station coordinates to prevent invalid lines
                if (!isValidStation(station)) {
                    continue; // Skip this station - warning already logged
                }
                
                const distance = fastHaversineDistance(centerLat, centerLng, station.lat, station.lng);
                results.push({
                    ...station,
                    distance: distance
                });
            }
            
            return results;
        }
        
        // Fast Haversine distance calculation (optimized for performance)
        function fastHaversineDistance(lat1, lng1, lat2, lng2) {
            const R = 6371000; // Earth's radius in meters
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const lat1Rad = lat1 * Math.PI / 180;
            const lat2Rad = lat2 * Math.PI / 180;
            
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                     Math.cos(lat1Rad) * Math.cos(lat2Rad) *
                     Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            
            return R * c;
        }
        
        // Pre-filter stations by rough bounding box for ultra-fast initial filtering
        function getStationsInRadius(center, stations, maxRadius = 5000) {
            // Use spatial index if available for much faster lookups
            if (stationIndex) {
                return stationIndex.getNearbyStations(center.lat, center.lng, maxRadius);
            }
            
            // Fallback to simple bounding box filtering
            const centerLat = center.lat;
            const centerLng = center.lng;
            
            // Rough degree conversion for quick filtering (1 degree ≈ 111km)
            const latDelta = maxRadius / 111000;
            const lngDelta = maxRadius / (111000 * Math.cos(centerLat * Math.PI / 180));
            
            return stations.filter(station => 
                Math.abs(station.lat - centerLat) <= latDelta &&
                Math.abs(station.lng - centerLng) <= lngDelta
            );
        }
        
        async function calculateOSMDistances(center, stations, calculationId = null) {
            try {
                // Validate input parameters
                if (!center || !center.lat || !center.lng || !stations || stations.length === 0) {
                    console.error('Invalid parameters for OSM distance calculation', { center, stationsCount: stations ? stations.length : 0 });
                    throw new Error('Invalid parameters');
                }
                
                // Check if calculation is still current
                if (calculationId && calculationId !== currentCalculationId) {
                    console.log(`⏭️ OSM calculation ${calculationId} cancelled at start`);
                    throw new Error('Calculation cancelled');
                }
                
                // Check cache first for instant response
                const cached = distanceCache.get(center.lat, center.lng);
                if (cached) {
                    console.log(`✅ Using cached OSM data for ${currentCity}`);
                    return cached; // Use cached data directly
                }
                
                console.log(`🔄 Calculating OSM routes for ${currentCity} with ${stations.length} stations...`);
                console.log(`📍 Sending OSM request with city: ${currentCity}`);
                const requestStart = performance.now();
                
                const response = await fetch(`${API_BASE_URL}/walking-distances-batch`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        center_lat: center.lat,
                        center_lng: center.lng,
                        stations: stations,
                        city: currentCity  // CRITICAL: Tell backend which city's network to use
                    })
                });
                
                // Check if calculation is still current after network request
                if (calculationId && calculationId !== currentCalculationId) {
                    console.log(`⏭️ OSM calculation ${calculationId} cancelled after network request`);
                    throw new Error('Calculation cancelled');
                }
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                const rawResult = data.stations || [];
                
                // Validate and clean OSM route data
                const result = rawResult.map(station => {
                    // Validate station coordinates
                    if (!isValidStation(station)) {
                        console.warn(`⚠️ OSM response contains invalid station:`, station.name);
                        return null;
                    }
                    
                    // Validate route data if present
                    if (station.route && Array.isArray(station.route)) {
                        const validRoute = station.route.filter(point => {
                            if (!Array.isArray(point) || point.length !== 2) return false;
                            const [lat, lng] = point;
                            if (typeof lat !== 'number' || typeof lng !== 'number') return false;
                            if (isNaN(lat) || isNaN(lng)) return false;
                            if (lat === 0 && lng === 0) return false;
                            if (Math.abs(lat) > 90 || Math.abs(lng) > 180) return false;
                            return true;
                        });
                        
                        if (validRoute.length < station.route.length) {
                            console.warn(`⚠️ Filtered ${station.route.length - validRoute.length} invalid route points for ${station.name}`);
                        }
                        
                        station.route = validRoute;
                    }
                    
                    return station;
                }).filter(station => station !== null);
                
                console.log(`✅ OSM validation: ${result.length}/${rawResult.length} stations valid`);
                
                // Debug: Log all stations being returned for debugging
                console.log('🔍 Detailed OSM response stations:', result.map(s => ({
                    name: s.name,
                    lat: s.lat,
                    lng: s.lng,
                    hasRoute: !!(s.route && s.route.length > 0),
                    routePoints: s.route ? s.route.length : 0
                })));
                
                const requestTime = performance.now() - requestStart;
                console.log(`✅ OSM calculation completed in ${requestTime.toFixed(0)}ms`);
                
                // Cache the result for instant future responses
                distanceCache.set(center.lat, center.lng, result);
                
                return result;
            } catch (error) {
                if (error.message === 'Calculation cancelled') {
                    throw error; // Re-throw cancellation errors
                }
                console.error('Error calculating OSM distances:', error);
                // Fallback to fully optimized Euclidean distance
                return calculateEuclideanDistancesWithCache(center);
            }
        }
        
        // --- Toggle Functions ---
        function toggleDistanceMode() {
            const previousMode = useOSMNetwork;
            useOSMNetwork = !useOSMNetwork;
            
            console.log(`🔄 Switching from ${previousMode ? 'OSM' : 'Euclidean'} to ${useOSMNetwork ? 'OSM' : 'Euclidean'} mode`);
            
            // Update UI immediately
            updateToggleUI();
            
            // Cancel any pending calculations from the previous mode
            currentCalculationId++;
            if (moveTimeout) {
                clearTimeout(moveTimeout);
                moveTimeout = null;
            }
            
            // Reset loading state
            isLoading = false;
            showLoading(false);
            
            // Recalculate with current map center in the new mode
            if (map) {
                const center = map.getCenter();
                updateClosestStationsWithCenter(center);
            }
        }
        
        function updateToggleUI() {
            const toggleSwitch = document.getElementById('toggle-switch');
            const euclideanLabel = document.getElementById('euclidean-label');
            const networkLabel = document.getElementById('network-label');
            
            if (useOSMNetwork) {
                toggleSwitch.classList.add('active');
                euclideanLabel.classList.add('inactive');
                networkLabel.classList.remove('inactive');
            } else {
                toggleSwitch.classList.remove('active');
                euclideanLabel.classList.remove('inactive');
                networkLabel.classList.add('inactive');
            }
        }
        
        function showLoading(show) {
            const loadingIndicator = document.getElementById('loading-indicator');
            loadingIndicator.style.display = show ? 'block' : 'none';
        }
        
        // This code has been moved inside initializeMap() function

        // Performance monitoring for distance calculations
        function measureDistanceCalculationPerformance(center, stations) {
            console.log(`Testing distance calculation performance with ${stations.length} stations...`);
            
            // Test 1: Original method (for comparison)
            const startOriginal = performance.now();
            const originalResults = stations.map(station => ({
                ...station,
                distance: center.distanceTo(L.latLng(station.lat, station.lng))
            }));
            const originalTime = performance.now() - startOriginal;
            
            // Test 2: Pre-filtering + optimized calculation
            const startOptimized = performance.now();
            const nearbyStations = getStationsInRadius(center, stations, 10000);
            const optimizedResults = calculateEuclideanDistances(center, nearbyStations);
            const optimizedTime = performance.now() - startOptimized;
            
            console.log(`Performance comparison:
                Original (all ${stations.length} stations): ${originalTime.toFixed(2)}ms
                Optimized (${nearbyStations.length} nearby): ${optimizedTime.toFixed(2)}ms
                Speed improvement: ${(originalTime / optimizedTime).toFixed(1)}x faster
                Stations filtered out: ${stations.length - nearbyStations.length}
            `);
            
            return {
                originalTime,
                optimizedTime,
                speedup: originalTime / optimizedTime,
                stationsFiltered: stations.length - nearbyStations.length
            };
        }
        

        // Optimized Euclidean distance calculation with caching
        function calculateEuclideanDistancesWithCache(center, maxRadius = 10000) {
            try {
                // Validate input parameters
                if (!center || !center.lat || !center.lng) {
                    console.error('Invalid center for Euclidean distance calculation', center);
                    return [];
                }
                
                const centerLat = center.lat;
                const centerLng = center.lng;
                
                // Check cache first
                const cached = euclideanCache.get(centerLat, centerLng);
                if (cached) {
                    console.log('Using cached Euclidean distance calculation');
                    return cached;
                }
                
                // Get nearby stations using spatial index
                const nearbyStations = getStationsInRadius(center, stations, maxRadius);
                
                if (nearbyStations.length === 0) {
                    console.warn('No nearby stations found, using all stations');
                    // Fallback to all stations if filtering returns empty
                    const fallbackResults = calculateEuclideanDistances(center, stations);
                    fallbackResults.sort((a, b) => a.distance - b.distance);
                    const top5 = fallbackResults.slice(0, 5);
                    euclideanCache.set(centerLat, centerLng, top5);
                    return top5;
                }
                
                // Calculate distances for nearby stations only
                const results = [];
                for (let i = 0; i < nearbyStations.length; i++) {
                    const station = nearbyStations[i];
                    const distance = fastHaversineDistance(centerLat, centerLng, station.lat, station.lng);
                    results.push({
                        ...station,
                        distance: distance
                    });
                }
                
                // Sort by distance and take top 5
                results.sort((a, b) => a.distance - b.distance);
                const top5 = results.slice(0, 5);
                
                // Cache the result
                euclideanCache.set(centerLat, centerLng, top5);
                
                console.log(`Calculated distances for ${nearbyStations.length}/${stations.length} stations (${((nearbyStations.length/stations.length)*100).toFixed(1)}% of total)`);
                
                return top5;
            } catch (error) {
                console.error('Error in calculateEuclideanDistancesWithCache:', error);
                // Fallback to simple calculation
                const fallbackResults = calculateEuclideanDistances(center, stations);
                fallbackResults.sort((a, b) => a.distance - b.distance);
                return fallbackResults.slice(0, 5);
            }
        }
        
        // --- Modal Functions ---
        function showInfoModal() {
            document.getElementById('info-modal').style.display = 'block';
        }
        
        function hideInfoModal() {
            document.getElementById('info-modal').style.display = 'none';
        }
        
        // Close modal when clicking outside of it
        window.onclick = function(event) {
            const modal = document.getElementById('info-modal');
            if (event.target === modal) {
                hideInfoModal();
            }
        }
        
        // Close modal with escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                hideInfoModal();
            }
        });
        
        // Initialize the app when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🌟 DOM Content Loaded - starting initialization...');
            initializeApp();
        });
        
        // Fallback initialization in case DOMContentLoaded already fired
        if (document.readyState === 'loading') {
            // Still loading, DOMContentLoaded will fire
            console.log('📝 Document is still loading, waiting for DOMContentLoaded...');
        } else {
            // Already loaded
            console.log('🌟 Document already loaded - starting initialization immediately...');
            initializeApp();
        }
    </script>
</body>
</html>
