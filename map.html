<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Interactive CDMX Metro Map (Live)</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #map {
            width: 100vw;
            height: 100vh;
        }
        .leaflet-container {
            background: #1a202c; /* Dark background for map tiles loading */
        }
        .center-crosshair {
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 3px #000, 0 0 5px #000;
        }
        .toggle-container {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(26, 32, 44, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        .toggle-button {
            display: flex;
            align-items: center;
            gap: 12px;
            background: transparent;
            border: none;
            color: #fff;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 8px;
            transition: all 0.2s ease;
        }
        .toggle-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        .toggle-labels {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .toggle-label {
            white-space: nowrap;
            transition: opacity 0.3s ease;
        }
        .toggle-label.inactive {
            opacity: 0.5;
        }
        .toggle-switch {
            position: relative;
            width: 44px;
            height: 24px;
            background: #4A5568;
            border-radius: 12px;
            transition: background-color 0.3s ease;
        }
        .toggle-switch.active {
            background: #ed8936;
        }
        .toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s ease;
        }
        .toggle-switch.active .toggle-slider {
            transform: translateX(20px);
        }
        .loading-indicator {
            display: none;
            margin-left: 8px;
            width: 16px;
            height: 16px;
            border: 2px solid #4A5568;
            border-top: 2px solid #ed8936;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Info Button Styles */
        .info-button {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 1000;
            width: 40px;
            height: 40px;
            background: rgba(26, 32, 44, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        .info-button:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.05);
        }
        
        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
        }
        .modal-content {
            background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%);
            margin: 5% auto;
            padding: 30px;
            border-radius: 16px;
            width: 90%;
            max-width: 600px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            color: #fff;
            font-family: 'Inter', sans-serif;
            line-height: 1.6;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .modal-title {
            font-size: 24px;
            font-weight: 700;
            margin: 0;
        }
        .close-button {
            background: none;
            border: none;
            color: #fff;
            font-size: 28px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.2s ease;
        }
        .close-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        .modal-text {
            font-size: 16px;
            margin-bottom: 15px;
        }
        .modal-link {
            color: #ed8936;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        .modal-link:hover {
            color: #fbb870;
            text-decoration: underline;
        }
        .github-section {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 12px;
            margin-top: 20px;
            border-left: 4px solid #ed8936;
        }
        .github-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: #ed8936;
            color: #1a202c;
            padding: 10px 16px;
            border-radius: 8px;
            text-decoration: none;
            font-weight: 600;
            margin-top: 10px;
            transition: all 0.2s ease;
        }
        .github-link:hover {
            background: #fbb870;
            transform: translateY(-1px);
        }
    </style>
</head>
<body class="bg-gray-900">

    <div id="map"></div>
    
    <!-- Info Button -->
    <button class="info-button" onclick="showInfoModal()" title="About this project">
        ‚ÑπÔ∏è
    </button>
    
    <!-- Toggle Container -->
    <div class="toggle-container">
        <button class="toggle-button" onclick="toggleDistanceMode()">
            <div class="toggle-labels">
                <span class="toggle-label" id="euclidean-label">Euclidean Distance</span>
                <span class="toggle-label inactive" id="network-label">Walking Network</span>
            </div>
            <div class="toggle-switch" id="toggle-switch">
                <div class="toggle-slider"></div>
            </div>
            <div class="loading-indicator" id="loading-indicator"></div>
        </button>
    </div>
    
    <!-- Info Modal -->
    <div id="info-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">CDMX Metro Spider Map</h2>
                <button class="close-button" onclick="hideInfoModal()">&times;</button>
            </div>
            <div class="modal-text">
                An interactive web map showing the 5 closest Mexico City metro stations to any location, with toggle between Euclidean and actual walking distances using OpenStreetMap routing.
            </div>
            <div class="modal-text">
                This project is inspired by <a href="https://carto.mx/webmap/spoke/" target="_blank" class="modal-link">Carlos Enrique V√°zquez Ju√°rez's original work</a> and builds upon it to create an open-source, enhanced version with additional features such as pedestrian network routing and high-performance network analysis.
            </div>
            <div class="github-section">
                <div class="modal-text">
                    <strong>Open Source Project</strong><br>
                    This is a completely open-source project available on GitHub. You can view the code, contribute improvements, report issues, or fork it for your own use.
                </div>
                <a href="https://github.com/liorsteinberg/Spider-Map" target="_blank" class="github-link">
                    üîó View on GitHub
                </a>
            </div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <script>
        // --- Configuration ---
        let useOSMNetwork = false; // Toggle between Euclidean and OSM network distance
        let isLoading = false;
        
        // API Configuration - works for both local development and Heroku
        const API_BASE_URL = window.location.origin;
        
        // --- DATA: Mexico City Metro Stations with Lat/Lng ---
        const stations = [
            { name: "Observatorio", lat: 19.4024, lng: -99.2005 }, { name: "Tacubaya", lat: 19.4036, lng: -99.1871 },
            { name: "Juanacatl√°n", lat: 19.412, lng: -99.182 }, { name: "Chapultepec", lat: 19.4205, lng: -99.1764 },
            { name: "Sevilla", lat: 19.422, lng: -99.171 }, { name: "Insurgentes", lat: 19.425, lng: -99.164 },
            { name: "Cuauht√©moc", lat: 19.428, lng: -99.157 }, { name: "Balderas", lat: 19.429, lng: -99.149 },
            { name: "Salto del Agua", lat: 19.427, lng: -99.143 }, { name: "Isabel la Cat√≥lica", lat: 19.428, lng: -99.138 },
            { name: "Pino Su√°rez", lat: 19.425, lng: -99.132 }, { name: "Merced", lat: 19.427, lng: -99.123 },
            { name: "Candelaria", lat: 19.428, lng: -99.119 }, { name: "San L√°zaro", lat: 19.43, lng: -99.113 },
            { name: "Moctezuma", lat: 19.431, lng: -99.106 }, { name: "Balbuena", lat: 19.429, lng: -99.1 },
            { name: "G√≥mez Far√≠as", lat: 19.426, lng: -99.088 }, { name: "Zaragoza", lat: 19.423, lng: -99.08 },
            { name: "Pantitl√°n", lat: 19.415, lng: -99.072 }, { name: "Cuatro Caminos", lat: 19.458, lng: -99.215 },
            { name: "Panteones", lat: 19.456, lng: -99.202 }, { name: "Tacuba", lat: 19.456, lng: -99.188 },
            { name: "Cuitl√°huac", lat: 19.46, lng: -99.175 }, { name: "Popotla", lat: 19.456, lng: -99.172 },
            { name: "Colegio Militar", lat: 19.452, lng: -99.168 }, { name: "Normal", lat: 19.448, lng: -99.165 },
            { name: "San Cosme", lat: 19.444, lng: -99.16 }, { name: "Revoluci√≥n", lat: 19.439, lng: -99.156 },
            { name: "Hidalgo", lat: 19.436, lng: -99.148 }, { name: "Bellas Artes", lat: 19.435, lng: -99.141 },
            { name: "Allende", lat: 19.436, lng: -99.137 }, { name: "Z√≥calo", lat: 19.432, lng: -99.133 },
            { name: "San Antonio Abad", lat: 19.419, lng: -99.133 }, { name: "Chabacano", lat: 19.406, lng: -99.133 },
            { name: "Viaducto", lat: 19.398, lng: -99.135 }, { name: "Xola", lat: 19.39, lng: -99.138 },
            { name: "Villa de Cort√©s", lat: 19.382, lng: -99.14 }, { name: "Nativitas", lat: 19.375, lng: -99.142 },
            { name: "Portales", lat: 19.366, lng: -99.144 }, { name: "Ermita", lat: 19.358, lng: -99.146 },
            { name: "General Anaya", lat: 19.35, lng: -99.148 }, { name: "Tasque√±a", lat: 19.34, lng: -99.145 },
            { name: "Indios Verdes", lat: 19.495, lng: -99.118 }, { name: "Deportivo 18 de Marzo", lat: 19.485, lng: -99.125 },
            { name: "Potrero", lat: 19.475, lng: -99.135 }, { name: "La Raza", lat: 19.465, lng: -99.14 },
            { name: "Tlatelolco", lat: 19.45, lng: -99.142 }, { name: "Guerrero", lat: 19.443, lng: -99.145 },
            { name: "Centro M√©dico", lat: 19.409, lng: -99.156 }, { name: "Etiop√≠a", lat: 19.398, lng: -99.159 },
            { name: "Eugenia", lat: 19.39, lng: -99.16 }, { name: "Divisi√≥n del Norte", lat: 19.382, lng: -99.162 },
            { name: "Zapata", lat: 19.373, lng: -99.165 }, { name: "Coyoac√°n", lat: 19.362, lng: -99.168 },
            { name: "Viveros", lat: 19.354, lng: -99.175 }, { name: "Miguel √Ångel de Quevedo", lat: 19.347, lng: -99.182 },
            { name: "Copilco", lat: 19.338, lng: -99.18 }, { name: "Universidad", lat: 19.33, lng: -99.175 },
            { name: "Mart√≠n Carrera", lat: 19.48, lng: -99.097 }, { name: "Talism√°n", lat: 19.475, lng: -99.105 },
            { name: "Bondojito", lat: 19.46, lng: -99.112 }, { name: "Consulado", lat: 19.45, lng: -99.118 },
            { name: "Fray Servando", lat: 19.42, lng: -99.128 }, { name: "Jamaica", lat: 19.412, lng: -99.118 },
            { name: "Santa Anita", lat: 19.403, lng: -99.113 }, { name: "El Rosario", lat: 19.505, lng: -99.215 },
            { name: "Tezoz√≥moc", lat: 19.5, lng: -99.205 }, { name: "UAM-Azcapotzalco", lat: 19.495, lng: -99.195 },
            { name: "Ferrer√≠a", lat: 19.49, lng: -99.18 }, { name: "Norte 45", lat: 19.485, lng: -99.168 },
            { name: "Vallejo", lat: 19.48, lng: -99.158 }, { name: "Instituto del Petr√≥leo", lat: 19.475, lng: -99.148 },
            { name: "Lindavista", lat: 19.482, lng: -99.135 }, { name: "La Villa-Bas√≠lica", lat: 19.485, lng: -99.11 },
            { name: "Garibaldi", lat: 19.441, lng: -99.139 }, { name: "San Juan de Letr√°n", lat: 19.43, lng: -99.14 },
            { name: "Doctores", lat: 19.42, lng: -99.146 }, { name: "Obrera", lat: 19.412, lng: -99.14 },
            { name: "L√°zaro C√°rdenas", lat: 19.408, lng: -99.148 }, { name: "Mixcoac", lat: 19.38, lng: -99.185 },
            { name: "San Antonio", lat: 19.39, lng: -99.18 }, { name: "San Pedro de los Pinos", lat: 19.395, lng: -99.182 },
            { name: "Polanco", lat: 19.432, lng: -99.192 }, { name: "Auditorio", lat: 19.425, lng: -99.195 },
        ];
        
        // Spatial grid index for ultra-fast station lookups
        class StationSpatialIndex {
            constructor(stations, gridSize = 0.01) { // ~1km grid cells
                this.gridSize = gridSize;
                this.grid = new Map();
                this.stations = stations;
                this.buildIndex();
            }
            
            buildIndex() {
                this.stations.forEach(station => {
                    const gridKey = this.getGridKey(station.lat, station.lng);
                    if (!this.grid.has(gridKey)) {
                        this.grid.set(gridKey, []);
                    }
                    this.grid.get(gridKey).push(station);
                });
                console.log(`Spatial index built with ${this.grid.size} grid cells for ${this.stations.length} stations`);
            }
            
            getGridKey(lat, lng) {
                const gridLat = Math.floor(lat / this.gridSize);
                const gridLng = Math.floor(lng / this.gridSize);
                return `${gridLat},${gridLng}`;
            }
            
            getNearbyStations(centerLat, centerLng, radius = 5000) {
                // Convert radius to grid cell distance
                const gridRadius = Math.ceil(radius / (this.gridSize * 111000)); // rough conversion
                const centerGridLat = Math.floor(centerLat / this.gridSize);
                const centerGridLng = Math.floor(centerLng / this.gridSize);
                
                const nearbyStations = [];
                
                // Check surrounding grid cells
                for (let latOffset = -gridRadius; latOffset <= gridRadius; latOffset++) {
                    for (let lngOffset = -gridRadius; lngOffset <= gridRadius; lngOffset++) {
                        const gridKey = `${centerGridLat + latOffset},${centerGridLng + lngOffset}`;
                        const cellStations = this.grid.get(gridKey);
                        if (cellStations) {
                            nearbyStations.push(...cellStations);
                        }
                    }
                }
                
                return nearbyStations;
            }
        }
        
        // Distance calculation cache for repeated queries with OSM route caching
        class DistanceCache {
            constructor(maxSize = 50) { // Reduced size for faster lookups
                this.cache = new Map();
                this.maxSize = maxSize;
            }
            
            getCacheKey(lat, lng, precision = 4) { // ~100m precision for responsive caching
                // Round to specified decimal places to create cache key
                const roundedLat = Math.round(lat * Math.pow(10, precision)) / Math.pow(10, precision);
                const roundedLng = Math.round(lng * Math.pow(10, precision)) / Math.pow(10, precision);
                return `${roundedLat},${roundedLng}`;
            }
            
            get(centerLat, centerLng) {
                const key = this.getCacheKey(centerLat, centerLng);
                const cached = this.cache.get(key);
                if (cached) {
                    console.log('üöÄ Using cached OSM routes - instant response!');
                }
                return cached;
            }
            
            set(centerLat, centerLng, result) {
                const key = this.getCacheKey(centerLat, centerLng);
                
                // Implement LRU cache by removing oldest entry
                if (this.cache.size >= this.maxSize) {
                    const firstKey = this.cache.keys().next().value;
                    this.cache.delete(firstKey);
                }
                
                this.cache.set(key, result);
                console.log(`üíæ Cached OSM routes for ${key} (${this.cache.size}/${this.maxSize})`);
            }
            
            clear() {
                this.cache.clear();
            }
        }

        // Initialize optimizations immediately with separate caches
        let stationIndex = null;
        const euclideanCache = new DistanceCache(50); // For euclidean distances  
        const distanceCache = new DistanceCache(30); // For OSM routes (smaller cache, bigger objects)
        
        console.log('Initializing spatial index for faster distance calculations...');
        stationIndex = new StationSpatialIndex(stations);
        
        // Performance test on initial load (optional - can be removed in production)
        if (stations.length > 0) {
            const testCenter = L.latLng(19.4326, -99.1332); // CDMX center
            setTimeout(() => measureDistanceCalculationPerformance(testCenter, stations), 1000);
        }
        
        // --- Map Initialization ---
        const map = L.map('map').setView([19.4326, -99.1332], 13);
        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd',
            maxZoom: 20
        }).addTo(map);

        // Show info modal on page load
        setTimeout(() => {
            showInfoModal();
        }, 500); // Small delay to ensure page is fully loaded

        // --- Layers ---
        const linesLayer = L.layerGroup().addTo(map);
        const highlightedStationsLayer = L.layerGroup().addTo(map);
        let centerMarker;

        // --- Throttle Function for Performance ---
        // This function limits how often another function can be called.
        // It prevents the update function from running too frequently during rapid map movements.
        function throttle(func, limit) {
            let inThrottle;
            return function() {
                const args = arguments;
                const context = this;
                if (!inThrottle) {
                    func.apply(context, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            }
        }

        // --- Core Logic ---
        async function updateClosestStations() {
            if (isLoading) return;
            
            const center = map.getCenter();
            
            // Always update center marker immediately for responsive feedback
            if (centerMarker) {
                map.removeLayer(centerMarker);
            }

            // Add a crosshair marker at the center
            const centerIcon = L.divIcon({
                className: 'center-crosshair',
                html: '<b>+</b>',
                iconSize: [24, 24],
                iconAnchor: [12, 12] // Center the icon
            });
            centerMarker = L.marker(center, { icon: centerIcon, interactive: false, zIndexOffset: 1000 }).addTo(map);

            // For OSM mode: keep old routes visible until new ones are ready (smooth transition)
            // For Euclidean mode: clear immediately since calculation is instant
            if (!useOSMNetwork) {
                linesLayer.clearLayers();
                highlightedStationsLayer.clearLayers();
            }

            let closestStations;
            
            if (useOSMNetwork) {
                // Use OSM network distance with batch processing
                isLoading = true;
                showLoading(true);
                
                try {
                    // OPTIMIZATION: Pre-filter to nearby stations only (much faster!)
                    const nearbyStations = getStationsInRadius(center, stations, 10000); // 10km radius
                    console.log(`OSM mode: Processing ${nearbyStations.length} nearby stations instead of ${stations.length} total stations`);
                    
                    closestStations = await calculateOSMDistances(center, nearbyStations);
                } catch (error) {
                    console.error('Error calculating OSM distances:', error);
                    // Fallback to fully optimized Euclidean distance with all optimizations
                    closestStations = calculateEuclideanDistancesWithCache(center);
                }
                
                isLoading = false;
                showLoading(false);
            } else {
                // Use fully optimized Euclidean distance calculation
                closestStations = calculateEuclideanDistancesWithCache(center);
                console.log('Euclidean mode - closest stations:', closestStations);
            }

            if (!closestStations || closestStations.length === 0) {
                console.error('No closest stations found!');
                return;
            }

            // For OSM mode: clear old routes only after new ones are ready (smooth transition)
            // For Euclidean mode: already cleared above for instant feedback
            if (useOSMNetwork) {
                linesLayer.clearLayers();
                highlightedStationsLayer.clearLayers();
            }

            closestStations.forEach(station => {
                const stationLatLng = L.latLng(station.lat, station.lng);
                
                // Draw route or straight line based on mode
                if (useOSMNetwork && station.route && station.route.length > 0) {
                    // Draw the actual walking route
                    L.polyline(station.route, { 
                        color: '#ed8936', 
                        weight: 3, 
                        opacity: 0.8,
                        dashArray: '5, 5'  // Dashed line to distinguish from straight lines
                    }).addTo(linesLayer);
                } else {
                    // Draw straight line
                    L.polyline([center, stationLatLng], { 
                        color: '#ed8936', 
                        weight: 2, 
                        opacity: 0.7 
                    }).addTo(linesLayer);
                }
                
                L.circleMarker(stationLatLng, { radius: 8, color: '#FFFFFF', weight: 2, fillColor: '#ed8936', fillOpacity: 1 })
                    .bindPopup(`<b>${station.name}</b><br>Distance: ${Math.round(station.distance)}m`).addTo(highlightedStationsLayer);
            });
        }
        
        // --- Distance Calculation Functions ---
        
        // Optimized Euclidean distance calculation using vectorized operations
        function calculateEuclideanDistances(center, stations) {
            const centerLat = center.lat;
            const centerLng = center.lng;
            const results = [];
            
            // Batch process stations for better performance
            for (let i = 0; i < stations.length; i++) {
                const station = stations[i];
                const distance = fastHaversineDistance(centerLat, centerLng, station.lat, station.lng);
                results.push({
                    ...station,
                    distance: distance
                });
            }
            
            return results;
        }
        
        // Fast Haversine distance calculation (optimized for performance)
        function fastHaversineDistance(lat1, lng1, lat2, lng2) {
            const R = 6371000; // Earth's radius in meters
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const lat1Rad = lat1 * Math.PI / 180;
            const lat2Rad = lat2 * Math.PI / 180;
            
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                     Math.cos(lat1Rad) * Math.cos(lat2Rad) *
                     Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            
            return R * c;
        }
        
        // Pre-filter stations by rough bounding box for ultra-fast initial filtering
        function getStationsInRadius(center, stations, maxRadius = 5000) {
            // Use spatial index if available for much faster lookups
            if (stationIndex) {
                return stationIndex.getNearbyStations(center.lat, center.lng, maxRadius);
            }
            
            // Fallback to simple bounding box filtering
            const centerLat = center.lat;
            const centerLng = center.lng;
            
            // Rough degree conversion for quick filtering (1 degree ‚âà 111km)
            const latDelta = maxRadius / 111000;
            const lngDelta = maxRadius / (111000 * Math.cos(centerLat * Math.PI / 180));
            
            return stations.filter(station => 
                Math.abs(station.lat - centerLat) <= latDelta &&
                Math.abs(station.lng - centerLng) <= lngDelta
            );
        }
        
        async function calculateOSMDistances(center, stations) {
            try {
                // Check cache first for instant response
                const cached = distanceCache.get(center.lat, center.lng);
                if (cached) {
                    return cached; // Instant response from cache!
                }
                
                console.log(`üîÑ Calculating OSM routes for ${stations.length} stations...`);
                const requestStart = performance.now();
                
                const response = await fetch(`${API_BASE_URL}/walking-distances-batch`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        center_lat: center.lat,
                        center_lng: center.lng,
                        stations: stations
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                const result = data.stations || [];
                
                const requestTime = performance.now() - requestStart;
                console.log(`‚úÖ OSM calculation completed in ${requestTime.toFixed(0)}ms`);
                
                // Cache the result for instant future responses
                distanceCache.set(center.lat, center.lng, result);
                
                return result;
            } catch (error) {
                console.error('Error calculating OSM distances:', error);
                // Fallback to fully optimized Euclidean distance
                return calculateEuclideanDistancesWithCache(center);
            }
        }
        
        // --- Toggle Functions ---
        function toggleDistanceMode() {
            if (isLoading) return;
            
            useOSMNetwork = !useOSMNetwork;
            
            const toggleSwitch = document.getElementById('toggle-switch');
            const euclideanLabel = document.getElementById('euclidean-label');
            const networkLabel = document.getElementById('network-label');
            
            if (useOSMNetwork) {
                toggleSwitch.classList.add('active');
                euclideanLabel.classList.add('inactive');
                networkLabel.classList.remove('inactive');
            } else {
                toggleSwitch.classList.remove('active');
                euclideanLabel.classList.remove('inactive');
                networkLabel.classList.add('inactive');
            }
            
            updateClosestStations();
        }
        
        function showLoading(show) {
            const loadingIndicator = document.getElementById('loading-indicator');
            loadingIndicator.style.display = show ? 'block' : 'none';
        }
        
        // --- Draw all stations as subtle background dots ---
        stations.forEach(station => {
            L.circleMarker([station.lat, station.lng], { radius: 4, color: '#4A5568', weight: 1, fillColor: '#718096', fillOpacity: 0.5 })
                .bindPopup(`<b>${station.name}</b>`).addTo(map);
        });

        // --- Event Listeners with Smart Throttling ---
        // Create different throttled versions for different modes
        const throttledUpdateEuclidean = throttle(updateClosestStations, 100);  // Fast for Euclidean
        const throttledUpdateOSM = throttle(updateClosestStations, 500);        // Slower for OSM to allow caching
        
        function smartThrottledUpdate() {
            if (useOSMNetwork) {
                // Use slower throttling for OSM to allow caching to work
                throttledUpdateOSM();
            } else {
                // Use fast throttling for Euclidean
                throttledUpdateEuclidean();
            }
        }

        // Use 'move' and 'zoom' for live updates, but with smart throttling based on mode
        map.on('move', smartThrottledUpdate);
        map.on('zoom', smartThrottledUpdate);

        // Also run the function one last time when movement stops to ensure the final position is perfect.
        map.on('moveend', updateClosestStations);

        // Initial call to draw the elements.
        updateClosestStations();

        // Performance monitoring for distance calculations
        function measureDistanceCalculationPerformance(center, stations) {
            console.log(`Testing distance calculation performance with ${stations.length} stations...`);
            
            // Test 1: Original method (for comparison)
            const startOriginal = performance.now();
            const originalResults = stations.map(station => ({
                ...station,
                distance: center.distanceTo(L.latLng(station.lat, station.lng))
            }));
            const originalTime = performance.now() - startOriginal;
            
            // Test 2: Pre-filtering + optimized calculation
            const startOptimized = performance.now();
            const nearbyStations = getStationsInRadius(center, stations, 10000);
            const optimizedResults = calculateEuclideanDistances(center, nearbyStations);
            const optimizedTime = performance.now() - startOptimized;
            
            console.log(`Performance comparison:
                Original (all ${stations.length} stations): ${originalTime.toFixed(2)}ms
                Optimized (${nearbyStations.length} nearby): ${optimizedTime.toFixed(2)}ms
                Speed improvement: ${(originalTime / optimizedTime).toFixed(1)}x faster
                Stations filtered out: ${stations.length - nearbyStations.length}
            `);
            
            return {
                originalTime,
                optimizedTime,
                speedup: originalTime / optimizedTime,
                stationsFiltered: stations.length - nearbyStations.length
            };
        }
        

        // Optimized Euclidean distance calculation with caching
        function calculateEuclideanDistancesWithCache(center, maxRadius = 10000) {
            try {
                const centerLat = center.lat;
                const centerLng = center.lng;
                
                // Check cache first
                const cached = euclideanCache.get(centerLat, centerLng);
                if (cached) {
                    console.log('Using cached Euclidean distance calculation');
                    return cached;
                }
                
                // Get nearby stations using spatial index
                const nearbyStations = getStationsInRadius(center, stations, maxRadius);
                
                if (nearbyStations.length === 0) {
                    console.warn('No nearby stations found, using all stations');
                    // Fallback to all stations if filtering returns empty
                    const fallbackResults = calculateEuclideanDistances(center, stations);
                    fallbackResults.sort((a, b) => a.distance - b.distance);
                    const top5 = fallbackResults.slice(0, 5);
                    euclideanCache.set(centerLat, centerLng, top5);
                    return top5;
                }
                
                // Calculate distances for nearby stations only
                const results = [];
                for (let i = 0; i < nearbyStations.length; i++) {
                    const station = nearbyStations[i];
                    const distance = fastHaversineDistance(centerLat, centerLng, station.lat, station.lng);
                    results.push({
                        ...station,
                        distance: distance
                    });
                }
                
                // Sort by distance and take top 5
                results.sort((a, b) => a.distance - b.distance);
                const top5 = results.slice(0, 5);
                
                // Cache the result
                euclideanCache.set(centerLat, centerLng, top5);
                
                console.log(`Calculated distances for ${nearbyStations.length}/${stations.length} stations (${((nearbyStations.length/stations.length)*100).toFixed(1)}% of total)`);
                
                return top5;
            } catch (error) {
                console.error('Error in calculateEuclideanDistancesWithCache:', error);
                // Fallback to simple calculation
                const fallbackResults = calculateEuclideanDistances(center, stations);
                fallbackResults.sort((a, b) => a.distance - b.distance);
                return fallbackResults.slice(0, 5);
            }
        }
        
        // --- Modal Functions ---
        function showInfoModal() {
            document.getElementById('info-modal').style.display = 'block';
        }
        
        function hideInfoModal() {
            document.getElementById('info-modal').style.display = 'none';
        }
        
        // Close modal when clicking outside of it
        window.onclick = function(event) {
            const modal = document.getElementById('info-modal');
            if (event.target === modal) {
                hideInfoModal();
            }
        }
        
        // Close modal with escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                hideInfoModal();
            }
        });
    </script>
</body>
</html>
